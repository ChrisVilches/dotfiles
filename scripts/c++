#!/bin/bash

# A bash utility for quickly running a simple C++ file using:
# c++ my_file.cpp
#
# Features:
# * stderr output becomes red (use std::cerr or fprintf(stderr, ...) to debug).
# * Caches the compiled file based on the code content (if the file doesn't change,
#   it will run the same pre-compiled binary).
#
# Instructions:
# Save as ~/bin/c++ (add to path)
# Speed up compile time when using #include <bits/stdc++.h>
# https://codeforces.com/blog/entry/53909 (precompile the header using the same flags as below),
# note that the compilation can be done in the same folder as the original header (no need to create a copy).

BIN_TEMP="/tmp/c++-bin-tmp"
DEV_FLAG="DEV"
# TODO: Not sure if having too many restrictions during development would make me slow.
# Specially during competitive programming problems.
# In fact, some of my current problems already show a lot of errors. Just turn them to warnings?
# Or start using strict C++ from now on? decide on this issue later.
QUALITY_FLAGS=(
	-Wall
	-Wextra
	-Werror
	-pedantic
	-Wshadow
	-Wnon-virtual-dtor
	-Wold-style-cast
	-Wcast-align
	-Wunused
	-Woverloaded-virtual
	-Wpedantic
	-Wnull-dereference
	-Wdouble-promotion
	-Wformat=2
)

COMPILE_FLAGS=(
	-O2
	-std=c++23
	"${QUALITY_FLAGS[@]}"
	-D"$DEV_FLAG"
)

color-stderr() (
	set -o pipefail
	"$@" 2>&1 >&3 | sed $'s,.*,\e[31m&\e[m,' >&2
) 3>&1

# Clean temp folder if there are too many files
clean_temp_dir() {
	local bin_temp_limit_files
	local files_in_bin_temp

	bin_temp_limit_files=30
	files_in_bin_temp=$(find "$BIN_TEMP" -mindepth 1 -maxdepth 1 2>/dev/null | wc -l)

	if [[ $files_in_bin_temp -ge $bin_temp_limit_files ]]; then
		rm $BIN_TEMP/*
	fi
}

if [ -z "$1" ]; then
	echo "File path missing" >&2
	exit 1
fi

clean_temp_dir

HASH=$(sha1sum "$1" | cut -d ' ' -f 1)

OUT_FILE="$BIN_TEMP/$HASH"

if [ ! -f "$OUT_FILE" ]; then
	mkdir -p "$BIN_TEMP"
	g++ "$1" "${COMPILE_FLAGS[@]}" -o "$OUT_FILE"
	gpp_exit=$?
	if [ $gpp_exit -ne 0 ]; then
		exit $gpp_exit
	fi
fi

color-stderr "$OUT_FILE"
