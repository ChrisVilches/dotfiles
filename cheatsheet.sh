# Some of these commands aren't tested (they were generated by an LLM), but I don't care!
# This sheet is meant to be constantly evolving.
# Meant to be used with fzf.
# NOTE: Repeated spaces may get squeezed.
# NOTE: Be careful with using tabs in this file, as they are used for splitting in fzf.
# NOTE: If there are multiple # in the command, it will work as long as there's
# a last # for the comment. So make sure to add a comment explaining the
# command.
# TODO: Some commands are fake/dummy from when I was testing the tool. Prune!

cat file_CURSOR_ | nl                        # Show line numbers to command output
chmod u+rwx file.txt                         # grants read, write, and execute permissions to the owner of the file.
chown user file.txt                          # changes the owner of "file.txt" to the specified user.
command "with _CURSOR_two cursors_CURSOR_"   #    testing two cursors
docker ps --format '{{.Names}}\t{{.Status}}' # List running containers
echo "this will # probably fail"             # just an echo (actually it works now, it grabs only the last comment marker)
echo "this _CURSOR_cursor should not show"   # this one_CURSOR_ also shouldn't show
# Remove this one? the other one using xargs is better.
# file="$(find . -type f | fzf)" && [ -n "$file" ] && bat "$file"               # Find file and open bat to preview it

tee /tmp/stdin.tmp && vim /tmp/stdin.tmp                                      # Write stdin content to a file and open it with vim
git ls-files --cached --others --exclude-standard | fzf | xargs -r bat        # Find files tracked by git and preview with bat
git ls-files --cached --others --exclude-standard | fzf | xargs -r -o vim     # Find files tracked by git and edit with vim
find . -type f | fzf | xargs -r bat                                           # Find file and open bat to preview it
find . -type f -iname "*.jpg"                                                 # find jpg files (case-insensitive)
find . -type f -mtime -7                                                      # find files modified in the last 7 days
find . -type f -name "*.log" -delete                                          # delete all .log files
find . -type f -name "*.md" -exec sed -i 's/foo/bar/g' {} \;                  # replace text inside all .md files
find . -type f -name "*.sh" -exec chmod +x {} \;                              # make all .sh files executable
find . -type f -name "*.tmp" -exec rm {} \;                                   # remove .tmp files using exec
find . -type f -name "*.txt"                                                  # find all .txt files under current directory
find . -type f -size +10M                                                     # find files larger than 10 MB
find . -type f -type f -perm -u+x                                             # find files executable by owner
find . -type f \( -name "*.cpp_CURSOR_" \) | fzf                              # Find all files with extension
find . -type f \( -name "*.jpg" -o -name "*.png" \) | fzf | xargs -r xdg-open # Find all photos / images and open them
find . \( -name node_modules -o -name .git \) -prune -o -type f               # find files and prune some folders like node_modules and .git
git diff                                                                      # Differences in git
git log --name-only                                                           # git log (name only)
gzip file.txt                                                                 # compresses the file "file.txt" and renames it as "file.txt.gz".
lsof -i :5999                                                                 # find program using port
netstat -tuln                                                                 # Shows all listening TCP and UDP connections.
less -S                                                                       # horizontal less pager
ps aux                                                                        # Show all processes
ps aux --sort=-%cpu | head -n 20 | less -S                                    # show processes sorted by CPU usage
ps aux --sort=-%cpu | fzf | awk '{print $2}' | xargs -r kill                  # find and kill process
ps auxf                                                                       # process tree or forest
tar -czvf archive.tar.gz files/                                               # creates a compressed tar archive named "archive.tar.gz" containing the files in the "files/" directory.
two_cursors "[_CURSOR_]"                                                      # the _CURSOR_ here (in the comment) should be shown
umask 022                                                                     # sets the default file permissions to read and write for the owner, and read-only for group and others.
watch -n 1 "_CURSOR_"                                                         # Periodically execute a command every N seconds
zip archive.txt_CURSOR_ file1.txt file2.txt                                   # creates a zip archive named "archive.zip" containing "file1.txt" and "file2.txt".
wc -l                                                                         # count lines in the stdin

grep -Ev '^\s*$' filepath # Show file contents ignoring blank lines (or only whitespace)

parallel --line-buffer --tag npm run ::: "serve_CURSOR_" "loop" # Run two node or npm commands in parallel

my_command_CURSOR_ | ts # Add timestamps to a command
ts                      # Add timestamps to a stdin

cut -d: -f1      # extract first field from colon-separated input
cut -d, -f2,4    # extract 2nd and 4th fields
cut -c1-3        # extract first 3 characters
cut -c4_CURSOR_- # extract characters from position 4 onward
cut -d' ' -f2    # extract second space-separated field
cut -f3          # extract 3rd field from tab-separated input

echo "very long    comment just to test the pager" # This has a very long command and comment to make the line very long and test what happens, does it show properly? or gets fucked up?
echo "just a line without a comment"

tr "[:lower:]" "[:upper:]" #  convert lowercase to uppercase
tr "[:upper:]" "[:lower:]" # convert uppercase to lowercase
tr -s ' '                  # squeeze repeated spaces
tr -d '[:digit:]'          # remove all digits
tr -s '\n'                 # squeeze multiple blank lines
tr ',' '\n'                # replace commas with newlines
tr ' ' '_'                 # replace spaces with underscores
tr '\t' ' '                # replace tabs with spaces

awk -F: '{print $1}'         # extract first field (colon-separated)
awk -F, '{print $2, $4}'     # extract 2nd and 4th fields
awk '{print substr($0,1,3)}' # extract first 3 characters
awk '{print substr($0,4)}'   # extract characters from position 4 onward
awk '{print $2_CURSOR_}'     # extract second space-separated field
awk '{print $3_CURSOR_}'     # extract 3rd field (tab is default FS)
awk '{print NF}'             # print number of fields in the line
awk '{print "[" $0 "]"}'     # print whole line wrapped in brackets
awk '{$1=$1;print}'          # trim leading and trailing spaces in a string

sed 's/:.*//'                   # extract first colon-separated field
sed 's/^[^,]*,\([^,]*\),.*/\1/' # extract 2nd comma-separated field
sed 's/^.\{3\}//'               # remove first 3 characters
sed 's/^\(...\).*/\1/'          # keep only first 3 characters
sed 's/^[^ ]* //'               # remove first space-separated field
sed 's/ \+/ /g'                 # squeeze multiple spaces into one
sed 's/.*/[\0]/'                # wrap whole line in brackets
sed 's/,/\n/g'                  # replace commas with newlines

xargs -I{} echo "[[_CURSOR_{}]]" # Wrap string inside a left and right strings
# This one works, but it's not better than the xargs one,
# and it messes the document highlighting up (it seems it's not 100% valid syntax).
# read -r stdintext && echo "[$stdintext]_CURSOR_" # Wrap string inside a left and right strings

bindkey -L | bat --color=always --language=zsh --plain | fzf --ansi # see available mappings for zsh

pacman -Qi | awk '/^Name/{name=$3} /^Installed Size/{print $4$5, name}' | sort -h # pacman show sorted by size
pacman -Qe                                                                        # explicitly installed packages only
pacman -Qd                                                                        # packages installed as dependencies
pacman -Qm                                                                        # foreign packages (AUR / not in repos)

pacman -Qi neovim # detailed info about an installed package
pacman -Ql neovim # list files owned by the package
pacman -Qk neovim # verify installed files vs database

pacman -Qo /usr/bin/nvim # who owns this package or binary

pacman -Qs ripgrep # search installed packages
pacman -Ss ripgrep # search in all repos

pacman -Qtd # orphaned dependencies (safe to review/remove)

sudo pacman -Rns "$(pacman -Qdtq)" # Remove orphans

pactree neovim     # dependency tree
pactree -r openssl # reverse deps (who needs it?)

du -sh *                         # Show the total size of each item in the current directory (human-readable)
du -sh .                         # Show the total size of the current directory
du -h --max-depth=1 /            # Summarize disk usage of top-level directories under /
du -ah . | sort -h               # List all files/dirs with sizes and sort from smallest to largest
du -ah . | sort -rh | head -n 10 # Find the 10 largest files/directories here
du -xhd1 /                       # Like --max-depth=1, but stay on the same filesystem (ignore mounted drives)
du -sh ~/.cache                  # Quickly see how big a cache directory is üßπ
du -ch *.log | tail -n 1         # Show the cumulative size of matching files (e.g., logs)

df -h               # Show free/used space on all mounted filesystems
df -h /             # Show disk usage for the filesystem containing /
df -Th              # Show filesystem types along with usage (ext4, btrfs, tmpfs, etc.)
df -i               # Show inode usage (useful when ‚Äúdisk full‚Äù isn‚Äôt about bytes)
df -h --total       # Add a total line summarizing all filesystems
df -h | sort -k5 -h # Sort filesystems by usage percentage
df -h /home         # Check space specifically for /home

rm -rf ~/.local/share/nvim/auto_session ~/.local/share/nvim/sessions # remove neovim sessions

tail -f ~/.local/state/nvim/lsp.log # see neovim lsp log
